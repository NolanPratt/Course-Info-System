This program utilizes a binary search tree to efficiently sort and store university course offerings from a CSV file, which contains lines of discrete courses that are differentiated by their course number, title, and a trailing list of course prerequisites. The approach used to determine which data structure would suit this application scenario consisted of in-depth evaluations between a vector, hash table, and binary search tree data structure. The binary search tree was decided to be the best fit within this scenario due to its efficient sorting an searching capabilities when concerned with implementing this solution within usable software for academic advisors to aid students with their semester course selections. The review of which data structure would be the best fit for this scenario encouraged the inclusion of more efficient search and sorting algorithms, leading to minimal processing time when academic advisors attempt to utilize the software.

This was my first learning experience in runtime complexity through the inclusion of Big-O analysis to determine which data structure would best fit the solution, so the period of research needed to understand the concept and apply these principles to this project was extensive but worth it as it allowed me to make the most accurate decision based on a numerical, analytical process of elimination. Upon the completion of this project, I now feel more competent in my ability to design system infrastructure by utilizing analytical techniques to determine a best-fit data structure for the application.

This project also reiterated the importance of writing documented and modular code. As the program's complexity grew throughout the development cycle, via the inclusion of multiple classes, which were responsible for handling discrete aspects of the application's execution procedure, it became apparent that my approach to actively documenting and developing modular components within the system led to a simpler polishing period for identifying and implementing bug fixes for various edge case scenarios. This portion of the development cycle reinforced my personal approach to developing maintainable, readable, and adaptable programs through the lack of nuance needing addressed during the debugging stage, leading to simpler and more efficient software development.
